## 构造函数的执行顺序，析构函数的执行顺序
首先调用**基类的构造函数**，然后调用**成员类对象的构造函数**，最后调用**派生类的构造函数**
派生类：利用继承机制，新的类从已有的类中派生。

## 虚析构函数的作用，父类的析构函数是否需要设置成虚函数
基类采用virtual虚析构函数的作用是防止内存泄漏。  
如果派生类中申请了内存空间，并在析构函数中进行释放。基类采用非析构函数，删除基类指针指向的派生类对象就不会触发动态绑定，因而只会调用基类的析构函数，派生类中申请的内存得不到释放，造成内存泄漏。

### 虚析构与纯虚析构

都可以解决非析构函数造成的内存泄漏问题。
```
class A{
    public:
        virtual ~A(){
            // 虚析构函数
        }

        virtual ~A()=0; // 纯虚析构函数
};

A::~A(){
    // 纯虚析构函数
    // 有了纯虚析构函数之后类变为抽象类，无法实例化对象
}
```
如果使用纯虚析构函数，那么一定需要定义。因为每一个派生类析构函数都会被编译器加以扩张，以静态调用的方式调用其每一个虚基类及上一层基类的析构函数。因此缺乏任一基类析构函数的定义，都会造成链接失败。

## 动态绑定

### C++中的动态绑定

静态绑定：程序运行前就已经知道方法是属于那个类的，在编译的时候就可以连接到类的中，定位到这个方法。

动态绑定：在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

动态绑定实现：

在C++中，通过基类的引用或指针调用虚函数时，发生动态绑定。（指针既可以指向基类对象，也可以指向派生类对象）。

C++中动态绑定是通过虚函数实现的。虚函数是通过一张虚函数表实现的。这个表中记录了虚函数的地址，解决继承、覆盖的问题，保证动态绑定时能够根据对象的实际类型调用正确的函数。

### 构造、析构函数可以调用虚函数吗

构造、析构函数中调用虚函数不会触发虚函数动态绑定。

虚函数在继承层次上可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员，这将导致不可预料的结果。

一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是指向最后派生的VTABLE（所有构造函数被调用后才会有最后派生的VTABLE）。

### 多态成立的三个条件：继承、虚函数重写、父类指针指向子类对象

父类对象和子类对象分别有vptr指针，指向虚函数表，表中存储函数入口地址，实现迟绑定（运行时，C++程序采取判断）